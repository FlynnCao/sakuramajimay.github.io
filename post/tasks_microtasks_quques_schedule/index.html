<!DOCTYPE html>
<html><head>
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

   
    <meta name="author" content="Sakuramaji-May">
  

  

  

  <meta name="generator" content="Hugo 0.88.1" />
  
  
  
  
  
  
  <title>first 🌟 五月雨</title>

  <meta property="og:title" content="first" />
<meta property="og:description" content="[翻译JavaScript中的队列、任务、和微任务 原文地址：https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
当我告诉我的同事 Matt Gaunt 我正在考虑在浏览器的事件循环中写一篇关于微任务队列和执行的文章时，他说“我跟你说实话，杰克，我不会读那个”。好吧，反正我已经写好了，所以我们都会坐在这里享受它，好吗？
实际上，如果您更喜欢视频，Philip Roberts 在 SConf 上就事件循环发表了精彩的演讲 - 微任务没有被涵盖，但它是对其余部分的一个很好的介绍。不管怎样，我们继续这个话题…
拿一点点 JavaScript 代码来说：
console.log(&#39;script start&#39;); setTimeout(function () { console.log(&#39;setTimeout&#39;); }, 0); Promise.resolve() .then(function () { console.log(&#39;promise1&#39;); }) .then(function () { console.log(&#39;promise2&#39;); }); console.log(&#39;script end&#39;); 控制台的日志应该以什么顺序出现？
小试牛刀 正确答案：script start、script end、promise1、promise2、setTimeout，但不同的浏览器会展示出不同的效果。
Microsoft Edge、Firefox 40、iOS Safari 和桌面 Safari 8.0.8 在 promise1 和 promise2 之前记录 setTimeout - 尽管它似乎是一个竞争条件。这真的很奇怪，因为 Firefox 39 和 Safari 8.0.7 一直都是正确的。
为什么这种情况发生了 Why this happens 要理解这一点，您需要知道事件循环如何处理任务（task)和微任务(microtask)。第一次遇到它时，这可能会让您大吃一惊。深呼吸…
每个“线程”都有自己的事件循环，因此每个网页行为都有自己的事件循环，因此它可以独立执行，而同一源上的所有窗口都共享一个事件循环，因为它们可以同步通信。事件循环持续运行，执行排在队列中的任务。每个事件循环都有属于他们自己的事件源（如单击按钮执行函数，则这个函数内的事件循环是独立出来的），但是浏览器可以在循环的每一轮中选择从哪个源中获取任务。这允许浏览器优先处理性能敏感的任务，例如用户输入。好吧好吧，我们继续……
 如果两个 URL 的 protocol、port (en-US) (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="uildDrafts/post/tasks_microtasks_quques_schedule/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2015-10-25T08:36:54-07:00" />
<meta property="article:modified_time" content="2015-10-25T08:36:54-07:00" />


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="first"/>
<meta name="twitter:description" content="[翻译JavaScript中的队列、任务、和微任务 原文地址：https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
当我告诉我的同事 Matt Gaunt 我正在考虑在浏览器的事件循环中写一篇关于微任务队列和执行的文章时，他说“我跟你说实话，杰克，我不会读那个”。好吧，反正我已经写好了，所以我们都会坐在这里享受它，好吗？
实际上，如果您更喜欢视频，Philip Roberts 在 SConf 上就事件循环发表了精彩的演讲 - 微任务没有被涵盖，但它是对其余部分的一个很好的介绍。不管怎样，我们继续这个话题…
拿一点点 JavaScript 代码来说：
console.log(&#39;script start&#39;); setTimeout(function () { console.log(&#39;setTimeout&#39;); }, 0); Promise.resolve() .then(function () { console.log(&#39;promise1&#39;); }) .then(function () { console.log(&#39;promise2&#39;); }); console.log(&#39;script end&#39;); 控制台的日志应该以什么顺序出现？
小试牛刀 正确答案：script start、script end、promise1、promise2、setTimeout，但不同的浏览器会展示出不同的效果。
Microsoft Edge、Firefox 40、iOS Safari 和桌面 Safari 8.0.8 在 promise1 和 promise2 之前记录 setTimeout - 尽管它似乎是一个竞争条件。这真的很奇怪，因为 Firefox 39 和 Safari 8.0.7 一直都是正确的。
为什么这种情况发生了 Why this happens 要理解这一点，您需要知道事件循环如何处理任务（task)和微任务(microtask)。第一次遇到它时，这可能会让您大吃一惊。深呼吸…
每个“线程”都有自己的事件循环，因此每个网页行为都有自己的事件循环，因此它可以独立执行，而同一源上的所有窗口都共享一个事件循环，因为它们可以同步通信。事件循环持续运行，执行排在队列中的任务。每个事件循环都有属于他们自己的事件源（如单击按钮执行函数，则这个函数内的事件循环是独立出来的），但是浏览器可以在循环的每一轮中选择从哪个源中获取任务。这允许浏览器优先处理性能敏感的任务，例如用户输入。好吧好吧，我们继续……
 如果两个 URL 的 protocol、port (en-US) (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 192."/>


  
  
  
  
  <link rel="stylesheet" href="/uildDrafts/assets/css/style.min.699f46622e3574a7f9ecca4c5877067845fe89ffcd9c4335df2dff23ddae215e.css" integrity="sha256-aZ9GYi41dKf57MpMWHcGeEX&#43;if/NnEM13y3/I92uIV4=">

  <script src="/uildDrafts/assets/js/main.min.182da266209851bc7c828aa7377f98f914e1e76c8decdd53a6cbe9bffea92cde.js" integrity="sha256-GC2iZiCYUbx8goqnN3&#43;Y&#43;RTh52yN7N1Tpsvpv/6pLN4="></script>
  
  </head><body><header class="header-container layout-block layout-padding">
  <div class="header-inner content-padding-large soft-size--large soft-style--box">
    <div class="header-logo">
      <a href="uildDrafts"><h1>五月雨</h1></a>
    </div>
    <nav class="header-nav">
      <div class="header-nav--btn">
        <div class="btn-item"></div>
        <div class="btn-item"></div>
        <div class="btn-item"></div>
      </div>
      <div class="header-nav--list">
        <div>
          
        </div>
      </div>
    </nav>
  </div>
</header><main id="content">
    

    <div class="single-container layout-block">
      <div class="article-info">
        <div class="article-header layout-padding">
          <div class="article-cover card-container content-padding-large soft-size--large soft-style--box ">

  <div class="card-cover">
    
  </div>

  <div class="card-text">
    <h1 class="card-text--title">first</h1>
    
      <p class="card-text--row">2015-10-25 08:36</p>
      
      
      

      
      
    
  </div>

</div>
        </div>

        <div class="article-content">
          <div class="markdown-body content-padding-large soft-size--large soft-style--box">
            <h1 id="翻译javascript中的队列任务和微任务">[翻译JavaScript中的队列、任务、和微任务</h1>
<p>原文地址：https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</p>
<p>当我告诉我的同事 Matt Gaunt 我正在考虑在浏览器的事件循环中写一篇关于微任务队列和执行的文章时，他说“我跟你说实话，杰克，我不会读那个”。好吧，反正我已经写好了，所以我们都会坐在这里享受它，好吗？</p>
<p>实际上，如果您更喜欢视频，Philip Roberts 在 <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">SConf</a> 上就事件循环发表了精彩的演讲 - 微任务没有被涵盖，但它是对其余部分的一个很好的介绍。不管怎样，我们继续这个话题…</p>
<p>拿一点点 JavaScript 代码来说：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;script start&#39;</span>);

<span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;setTimeout&#39;</span>);
}, <span style="color:#ae81ff">0</span>);

Promise.<span style="color:#a6e22e">resolve</span>()
  .<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;promise1&#39;</span>);
  })
  .<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;promise2&#39;</span>);
  });

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;script end&#39;</span>);
</code></pre></div><p>控制台的日志应该以什么顺序出现？</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>正确答案：script start、script end、promise1、promise2、setTimeout，但不同的浏览器会展示出不同的效果。</p>
<p>Microsoft Edge、Firefox 40、iOS Safari 和桌面 Safari 8.0.8 在 promise1 和 promise2 之前记录 setTimeout - 尽管它似乎是一个竞争条件。这真的很奇怪，因为 Firefox 39 和 Safari 8.0.7 一直都是正确的。</p>
<h2 id="为什么这种情况发生了-why-this-happens">为什么这种情况发生了 Why this happens</h2>
<p>要理解这一点，您需要知道事件循环如何处理任务（task)和微任务(microtask)。第一次遇到它时，这可能会让您大吃一惊。深呼吸…</p>
<p>每个“线程”都有自己的事件循环，因此每个网页行为都有自己的事件循环，因此它可以独立执行，而<strong>同一源</strong>上的所有窗口都共享一个事件循环，因为它们可以同步通信。事件循环持续运行，执行排在队列中的任务。每个事件循环都有属于他们自己的事件源（如单击按钮执行函数，则这个函数内的事件循环是独立出来的），但是浏览器可以在循环的每一轮中选择从哪个源中获取任务。这允许浏览器优先处理性能敏感的任务，例如用户输入。好吧好吧，我们继续……</p>
<blockquote>
<p>如果两个 URL 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol" target="_blank" rel="noopener">protocol</a>、<a href="https://developer.mozilla.org/en-US/docs/Glossary/Port" target="_blank" rel="noopener">port (en-US)</a> (如果有指定的话)和 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Host" target="_blank" rel="noopener">host</a> 都相同的话，则这两个 URL 是<em>同源</em>。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 <code>192.168.0.201:8088/index.html</code>和<code>192.168.0.201:8088/login.html</code>就是同源</p>
</blockquote>
<p><strong>任务</strong>是经过调度的，因此浏览器可以从其内部进入 JavaScript/DOM 领域，并确保这些操作按顺序发生。在任务之间，浏览器可能会呈现更新。从鼠标点击到事件回调需要安排一个任务，解析 HTML 也是如此，在上面的例子中就是<strong>setTimeout</strong>。</p>
<p>setTimeout 等待给定的延迟，然后为其回调安排一个新<strong>任务</strong>。这就是为什么在脚本结束后记录 setTimeout 的原因，因为记录脚本结束是第一个任务的一部分，而 setTimeout 记录在一个<strong>单独的任务</strong>中。是的，我们快结束了，但我需要你在接下来的一段时间里保持坚强……</p>
<blockquote>
<p>注意，setTimeout的任务和设置触发setTimeout的函数的任务本质上没任何区别 因此他们必须分道扬镳</p>
</blockquote>
<p><strong>微任务</strong>通常被安排在当前执行的脚本之后<em>应该立即发生的事情</em>上，例如对一批操作做出反应，或者在不承担全新任务损失的情况下使某些事情异步。只要没有其他 JavaScript 在执行中，并且在每个任务结束时，微任务队列就会在回调之后处理。在微任务期间排队的任何其他微任务都会添加到队列的末尾并进行处理。微任务包括变化观察者（Observer Watcher&ndash;Vue中大量使用的）的回调，还有如上例所示的Promise回调。</p>
<p>一旦 promise 成立，或者如果它已经成立，它就会将一个<strong>微任务</strong>排队等待它的宿主任务回调。这确保了Promise回调是异步的，即使Promise已处于解决状态(fullfilled)。因此，针对已解决的承诺调用 <code>.then(yet, nay) </code>会立即将微任务排入队列。这就是为什么在脚本结束后记录 promise1 和 promise2 的原因，因为当前运行的脚本必须在处理<strong>微任务</strong>之前完成。 promise1 和 promise2 在 setTimeout 之前打印，因为<strong>微任务</strong>总是在下一个<strong>任务</strong>之前发生。</p>
<p>现在我们来重新审视一下先前的代码&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;script start&#39;</span>);

<span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;setTimeout&#39;</span>);
}, <span style="color:#ae81ff">0</span>);

Promise.<span style="color:#a6e22e">resolve</span>()
  .<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;promise1&#39;</span>);
  })
  .<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;promise2&#39;</span>);
  });

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;script end&#39;</span>);
</code></pre></div><p>是的，没错，我创建了一个动画分步图。你星期六是怎么度过的？和朋友出去晒太阳？嗯，我没有。嗯，如果从我惊人的 UI 设计中看不清楚，请单击上面的箭头前进。</p>
<blockquote>
<p>这里建议回原文使用动画来跑一遍代码</p>
</blockquote>
<h3 id="为什么一些浏览器不是这样的了解即可">为什么一些浏览器不是这样的(了解即可)</h3>
<p>一些浏览器会在控制台打印Script Start、Script End、setTimeout、promise1、promise2。他们在 setTimeout 之后运行Promise回调。他们很可能将 Promise 回调作为新任务的一部分而不是<strong>微任务</strong>。</p>
<p>这有点情有可原，因为Promise来自 ECMAScript 而不是 HTML。 ECMAScript 具有类似于<strong>微任务</strong>的“<strong>作业</strong>”概念，但除了模糊的邮件列表讨论之外，这种关系并不明确。然而，普遍的共识是Promise应该是<strong>微任务队列</strong>的一部分，这是有充分理由的。</p>
<p>将 Promise 视为任务会导致性能问题，因为回调可能会被与任务相关的事情（例如渲染）不必要地延迟）。由于与其他任务源的交互，它还会导致不确定性，并且可能会中断与其他 API 的交互，我们稍后会详细讨论这个。</p>
<p>这是使用微任务进行Promise的 Edge 证据。 WebKit nightly 正在做正确的事情，所以我认为 Safari 最终会修复它，它似乎在 Firefox 43 中得到修复。</p>
<p>非常有趣的是，Safari 和 Firefox 在这里都出现了倒退问题，此后已修复。我想知道这是否只是巧合。</p>
<h2 id="怎么分辨一些东西用了任务还是微任务">怎么分辨一些东西用了任务还是微任务</h2>
<p>测试是一种方式。查看与 promises 和 setTimeout 相关的日志何时出现，尽管您很依赖正确的结果。</p>
<p>更好的方法是直接查找细节。例如，setTimeout 的第 14 步将任务排队，而将突变记录排队的第 5 步将微任务排队。</p>
<p>如前所述，在 ECMAScript 领域，他们将<strong>微任务</strong>称为“<strong>作业</strong>”。在 PerformPromiseThen 的步骤 8.a 中，调用 EnqueueJob 将<strong>微任务</strong>排队。</p>
<p>现在，我们来看看一个更复杂的例子。这时你心里有个声音会说： &ldquo;不，我还没有准备好！&quot;。别理他，你已经准备好了。我们来做这个&hellip;</p>
<h2 id="最终决战">最终决战</h2>
<p>在写这篇文章之前，我已经弄错了。这是一些html：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;outer&#34;</span>&gt;
  &lt;<span style="color:#f92672">div</span> <span style="color:#a6e22e">class</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;inner&#34;</span>&gt;&lt;/<span style="color:#f92672">div</span>&gt;
&lt;/<span style="color:#f92672">div</span>&gt;
</code></pre></div><p>给定下面的 JS，如果我点击 div.inner 会打印什么？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// Let&#39;s get hold of those elements
</span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">outer</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;.outer&#39;</span>);
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">inner</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">querySelector</span>(<span style="color:#e6db74">&#39;.inner&#39;</span>);

<span style="color:#75715e">// Let&#39;s listen for attribute changes on the
</span><span style="color:#75715e">// outer element
</span><span style="color:#75715e"></span><span style="color:#66d9ef">new</span> <span style="color:#a6e22e">MutationObserver</span>(<span style="color:#66d9ef">function</span> () {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;mutate&#39;</span>);
}).<span style="color:#a6e22e">observe</span>(<span style="color:#a6e22e">outer</span>, {
  <span style="color:#a6e22e">attributes</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
});

<span style="color:#75715e">// Here&#39;s a click listener…
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">onClick</span>() {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;click&#39;</span>);

  <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;timeout&#39;</span>);
  }, <span style="color:#ae81ff">0</span>);

  Promise.<span style="color:#a6e22e">resolve</span>().<span style="color:#a6e22e">then</span>(<span style="color:#66d9ef">function</span> () {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;promise&#39;</span>);
  });

  <span style="color:#a6e22e">outer</span>.<span style="color:#a6e22e">setAttribute</span>(<span style="color:#e6db74">&#39;data-random&#39;</span>, Math.<span style="color:#a6e22e">random</span>());
}

<span style="color:#75715e">// …which we&#39;ll attach to both elements
</span><span style="color:#75715e"></span><span style="color:#a6e22e">inner</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#39;click&#39;</span>, <span style="color:#a6e22e">onClick</span>);
<span style="color:#a6e22e">outer</span>.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#39;click&#39;</span>, <span style="color:#a6e22e">onClick</span>);
</code></pre></div><p>继续，在查看答案之前先试一试。提示：日志可以发生不止一次。</p>
<h2 id="答案">答案</h2>
<p>单击inner的时候</p>
<p>click
promise
mutate
click
promise
mutate
timeout
timeout</p>
<p>单击outer的时候</p>
<p>click
promise
mutate
timeout</p>
<blockquote>
<p>你的猜测不一样吗？如果是这样，您可能仍然是对的。有的浏览器中可能效果不一致，以Chrome浏览器为标准答案</p>
</blockquote>
<h2 id="谁是对的-whos-right">谁是对的？ Who&rsquo;s Right</h2>
<p>调度 &lsquo;click&rsquo; 事件是一项任务。变异观察者(Mutation Observer)和Promise回调被视为<strong>微任务</strong>并排队。 setTimeout 的回调被视为<strong>任务</strong>并排队。</p>
<blockquote>
<p>这里建议回原文使用动画来跑一遍代码</p>
</blockquote>
<p>在每一次侦听器回调结束后&hellip;</p>
<blockquote>
<p>如果脚本设置对象堆栈现在为空，则执行微任务检查点
— HTML：回调步骤 3 后的清理</p>
</blockquote>
<p>以前，这意味着微任务在侦听器回调之间运行，但 .click() 导致事件同步调度，因此调用 .click() 的脚本仍在回调之间的堆栈中。上述规则确保微任务不会中断正在执行的 JavaScript。这意味着我们不会在侦听器回调之间处理微任务队列，而是在两个侦听器之后处理它们。</p>
<h2 id="这些重要吗">这些重要吗</h2>
<p>作者在这里聊了聊之前遇到的bug，建议大家用最新版本的浏览器调试，屁事没有</p>
<h2 id="你做到了">你做到了！</h2>
<p>总结：</p>
<ul>
<li><strong>任务</strong>按顺序执行，但是浏览器可能会在两个任务之间<strong>重渲染</strong>网页</li>
<li><strong>微任务</strong>按顺序执行，且在以下情况下执行：
<ul>
<li>每次回调函数结束后，只要没有JS代码在执行中</li>
<li>每次<strong>任务</strong>结束后</li>
</ul>
</li>
</ul>
<p>希望你现在按照自己的方式理解了事件循环（event loop），至少知道如何去做或者如何躺平。</p>

          </div>
        </div>
                 
      
  
  
  
  

  

  <div class="article-paging">
    
    
  </div>
</div>
  <aside class="widget-info">
    
<section class="aside-widget widget-author content-padding-large soft-size--large soft-style--box">
  <div class="widget-body">
    <div class="author-box avatar">
      
      <img class="author-avatar soft-size--round soft-style--box" src="https://s.gravatar.com/avatar/7b5a0b07a98895278cfa862b1f32ae8f?s=200&amp;r=g&amp;d=retro" alt="Sakuramaji-May">
      
      <h2 class="author-name text-ellipsis">Sakuramaji-May</h2>
      
      <p class="author-desc text-ellipsis">人と人との繋がりだけは大切にせなあかん。ロボットみたいな仕事だけはしたらあかんど。</p>
      
    </div>
  </div>
</section>


    


    











    





    




  </aside>
</div>
  </main><footer class="footer-container layout-block">
  
  <div class="social-icons">
    
      <a class="soft-size--primary soft-style--box" href="https://github.com/FlynnCao" target="_blank" rel="noopener noreferrer">
          
        <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
        </svg>
        

        

        

        

        
      </a>
    
  </div>
  

  <div class="colour-bar"></div>
  
  

  

  <p>
    Powered by
    <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a>
    Theme - 
    <a href="https://github.com/miiiku/hugo-theme-kagome" target="_blank" rel="noopener noreferrer author">kagome</a>
  </p>

  <p>
    <a href="javascript:;" id="theme-light">🌞 light</a>
    <a href="javascript:;" id="theme-dark">🌛 dark</a>
    <a href="javascript:;" id="theme-auto">🤖️ auto</a>
  </p>
</footer>







</body>

</html>