<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>五月雨</title>
    <link>uildDrafts/</link>
    <description>Recent content on 五月雨</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>guanquanhong@163.com (Sakuramaji-May)</managingEditor>
    <webMaster>guanquanhong@163.com (Sakuramaji-May)</webMaster>
    <lastBuildDate>Sun, 25 Oct 2015 08:36:54 -0700</lastBuildDate><atom:link href="uildDrafts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>first</title>
      <link>uildDrafts/post/tasks_microtasks_quques_schedule/</link>
      <pubDate>Sun, 25 Oct 2015 08:36:54 -0700</pubDate>
      <author>guanquanhong@163.com (Sakuramaji-May)</author>
      <guid>uildDrafts/post/tasks_microtasks_quques_schedule/</guid>
      <description>[翻译JavaScript中的队列、任务、和微任务 原文地址：https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
当我告诉我的同事 Matt Gaunt 我正在考虑在浏览器的事件循环中写一篇关于微任务队列和执行的文章时，他说“我跟你说实话，杰克，我不会读那个”。好吧，反正我已经写好了，所以我们都会坐在这里享受它，好吗？
实际上，如果您更喜欢视频，Philip Roberts 在 SConf 上就事件循环发表了精彩的演讲 - 微任务没有被涵盖，但它是对其余部分的一个很好的介绍。不管怎样，我们继续这个话题…
拿一点点 JavaScript 代码来说：
console.log(&amp;#39;script start&amp;#39;); setTimeout(function () { console.log(&amp;#39;setTimeout&amp;#39;); }, 0); Promise.resolve() .then(function () { console.log(&amp;#39;promise1&amp;#39;); }) .then(function () { console.log(&amp;#39;promise2&amp;#39;); }); console.log(&amp;#39;script end&amp;#39;); 控制台的日志应该以什么顺序出现？
小试牛刀 正确答案：script start、script end、promise1、promise2、setTimeout，但不同的浏览器会展示出不同的效果。
Microsoft Edge、Firefox 40、iOS Safari 和桌面 Safari 8.0.8 在 promise1 和 promise2 之前记录 setTimeout - 尽管它似乎是一个竞争条件。这真的很奇怪，因为 Firefox 39 和 Safari 8.0.7 一直都是正确的。
为什么这种情况发生了 Why this happens 要理解这一点，您需要知道事件循环如何处理任务（task)和微任务(microtask)。第一次遇到它时，这可能会让您大吃一惊。深呼吸…
每个“线程”都有自己的事件循环，因此每个网页行为都有自己的事件循环，因此它可以独立执行，而同一源上的所有窗口都共享一个事件循环，因为它们可以同步通信。事件循环持续运行，执行排在队列中的任务。每个事件循环都有属于他们自己的事件源（如单击按钮执行函数，则这个函数内的事件循环是独立出来的），但是浏览器可以在循环的每一轮中选择从哪个源中获取任务。这允许浏览器优先处理性能敏感的任务，例如用户输入。好吧好吧，我们继续……
 如果两个 URL 的 protocol、port (en-US) (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。 192.</description>
    </item>
    
  </channel>
</rss>